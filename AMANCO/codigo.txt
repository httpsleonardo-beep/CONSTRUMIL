import tkinter as tk
from tkinter import filedialog, messagebox
import re
import pandas as pd
import pdfplumber
from pathlib import Path
import warnings
from openpyxl.styles import PatternFill, Font

warnings.filterwarnings('ignore')


class PriceComparator:
    """
    Classe para comparar pre√ßos entre arquivo PDF e planilha Excel.
    """

    def __init__(self, excel_path, pdf_path):
        """
        Inicializa o comparador com os caminhos dos arquivos.

        Args:
            excel_path (str): Caminho para o arquivo Excel
            pdf_path (str): Caminho para o arquivo PDF
        """
        self.excel_path = excel_path
        self.pdf_path = pdf_path
        self.df_excel = None
        self.df_pdf = None

    def extract_product_code(self, product_text):
        """
        Extrai o c√≥digo do produto do texto da coluna Produto.
        Procura por sequ√™ncias de 4-6 d√≠gitos no final ou meio do texto.

        Args:
            product_text (str): Texto contendo o c√≥digo do produto

        Returns:
            str: C√≥digo do produto encontrado ou None
        """
        if pd.isna(product_text):
            return None

        # Procura por sequ√™ncias de 4-6 d√≠gitos
        matches = re.findall(r'\b(\d{4,6})\b', str(product_text))
        # Retorna o √∫ltimo c√≥digo encontrado (geralmente est√° no final)
        return matches[-1] if matches else None

    def clean_price(self, price_text):
        """
        Limpa e converte texto de pre√ßo para float.
        Remove 'R$', pontos de milhar e substitui v√≠rgula por ponto.

        Args:
            price_text (str): Texto do pre√ßo (ex: 'R$ 5,01')

        Returns:
            float: Valor num√©rico do pre√ßo
        """
        if pd.isna(price_text):
            return None

        # Remove R$, espa√ßos e converte v√≠rgula para ponto
        price_str = str(price_text).replace('R$', '').replace('.', '').replace(',', '.').strip()

        try:
            return float(price_str)
        except ValueError:
            return None

    def read_excel(self):
        """
        L√™ a planilha Excel e extrai os c√≥digos dos produtos.
        """
        print(f"üìä Lendo arquivo Excel: {self.excel_path}")

        try:
            self.df_excel = pd.read_excel(self.excel_path)

            print(f"   Colunas encontradas: {list(self.df_excel.columns)}")

            # Extrai c√≥digo do produto da coluna 'Produto'
            self.df_excel['C√≥digo Extra√≠do'] = self.df_excel['Produto'].apply(
                self.extract_product_code
            )

            # Limpa a coluna 'Compra' se existir
            if 'Compra' in self.df_excel.columns:
                self.df_excel['Compra'] = pd.to_numeric(
                    self.df_excel['Compra'], errors='coerce'
                )

            # Limpa a coluna 'Valor de compra' se existir
            if 'Valor de compra' in self.df_excel.columns:
                self.df_excel['Valor de compra'] = pd.to_numeric(
                    self.df_excel['Valor de compra'], errors='coerce'
                )

            print(f"‚úÖ Excel lido com sucesso: {len(self.df_excel)} linhas")
            print(f"   C√≥digos extra√≠dos: {self.df_excel['C√≥digo Extra√≠do'].notna().sum()}")

            # Mostra alguns exemplos
            if not self.df_excel.empty:
                print(f"\n   Exemplos de c√≥digos extra√≠dos:")
                for idx, row in self.df_excel.head(3).iterrows():
                    print(f"   - {row.get('Produto', 'N/A')} ‚Üí C√≥digo: {row['C√≥digo Extra√≠do']}")

        except Exception as e:
            print(f"‚ùå Erro ao ler Excel: {e}")
            raise

    def read_pdf(self):
        """
        L√™ o arquivo PDF e extrai as informa√ß√µes de c√≥digo, quantidade e pre√ßo.
        Usa m√∫ltiplas estrat√©gias para extrair os dados.
        """
        print(f"\nüìÑ Lendo arquivo PDF: {self.pdf_path}")

        try:
            pdf_data = []

            with pdfplumber.open(self.pdf_path) as pdf:
                print(f"   Total de p√°ginas: {len(pdf.pages)}")

                for page_num, page in enumerate(pdf.pages, 1):
                    print(f"   Processando p√°gina {page_num}...")

                    # Estrat√©gia 1: Extrai tabelas estruturadas
                    tables = page.extract_tables()

                    if tables:
                        for table_idx, table in enumerate(tables):
                            if not table or len(table) < 2:
                                continue

                            print(f"      Tabela {table_idx + 1} encontrada com {len(table)} linhas")

                            # Mostra o cabe√ßalho para debug
                            header = [str(h).lower() if h else '' for h in table[0]]
                            print(f"      Cabe√ßalho: {header}")

                            # Procura pelos √≠ndices das colunas
                            codigo_idx = None
                            qtde_idx = None
                            preco_idx = None

                            for i, h in enumerate(header):
                                if 'c√≥digo' in h or 'codigo' in h:
                                    codigo_idx = i
                                if 'qtde' in h or 'quantidade' in h:
                                    qtde_idx = i
                                if 'pre√ßo l√≠q' in h or 'preco liq' in h or 'pre√ßo liq' in h:
                                    preco_idx = i

                            print(f"      √çndices: C√≥digo={codigo_idx}, Qtde={qtde_idx}, Pre√ßo={preco_idx}")

                            if None in (codigo_idx, qtde_idx, preco_idx):
                                print(f"      ‚ö†Ô∏è  Colunas necess√°rias n√£o encontradas nesta tabela")
                                continue

                            # Processa cada linha da tabela
                            for row_idx, row in enumerate(table[1:], 1):
                                try:
                                    if len(row) > max(codigo_idx, qtde_idx, preco_idx):
                                        codigo = str(row[codigo_idx]).strip() if row[codigo_idx] else None
                                        qtde = row[qtde_idx]
                                        preco = row[preco_idx]

                                        # Valida se h√° c√≥digo (4-6 d√≠gitos)
                                        if codigo and re.match(r'^\d{4,6}$', codigo):
                                            pdf_data.append({
                                                'C√≥digo_PDF': codigo,
                                                'Qtde_PDF': qtde,
                                                'Pre√ßo_L√≠q_PDF': preco
                                            })

                                except Exception as e:
                                    continue

                    # Estrat√©gia 2: Se n√£o encontrou tabelas, tenta extrair texto
                    if not tables or not pdf_data:
                        text = page.extract_text()
                        if text:
                            print(f"      Tentando extrair do texto bruto...")
                            # Procura por padr√µes de linhas de produtos
                            lines = text.split('\n')
                            for line in lines:
                                match = re.match(
                                    r'^(\d{4,6})\s+.*?(?:BR\d+|0\d+)\s*-\s*.*?\s+(\d+)\s+R\$\s*([\d.,]+)',
                                    line
                                )
                                if match:
                                    codigo = match.group(1)
                                    qtde = match.group(2)
                                    preco = match.group(3)

                                    pdf_data.append({
                                        'C√≥digo_PDF': codigo,
                                        'Qtde_PDF': qtde,
                                        'Pre√ßo_L√≠q_PDF': preco
                                    })

            self.df_pdf = pd.DataFrame(pdf_data)

            # Limpa os valores de quantidade e pre√ßo
            if not self.df_pdf.empty:
                self.df_pdf['Qtde_PDF'] = pd.to_numeric(
                    self.df_pdf['Qtde_PDF'], errors='coerce'
                )
                self.df_pdf['Pre√ßo_L√≠q_PDF'] = self.df_pdf['Pre√ßo_L√≠q_PDF'].apply(
                    self.clean_price
                )

                # Remove duplicatas mantendo a primeira ocorr√™ncia
                self.df_pdf = self.df_pdf.drop_duplicates(subset=['C√≥digo_PDF'], keep='first')

            print(f"‚úÖ PDF lido com sucesso: {len(self.df_pdf)} itens √∫nicos extra√≠dos")

            # Mostra alguns exemplos
            if not self.df_pdf.empty:
                print(f"\n   Exemplos de itens extra√≠dos do PDF:")
                for idx, row in self.df_pdf.head(3).iterrows():
                    print(
                        f"   - C√≥digo: {row['C√≥digo_PDF']} | Qtde: {row['Qtde_PDF']} | Pre√ßo: R$ {row['Pre√ßo_L√≠q_PDF']}")
            else:
                print("\n   ‚ö†Ô∏è  ATEN√á√ÉO: Nenhum item foi extra√≠do do PDF!")
                print("   Verifique se o PDF cont√©m tabelas ou se a estrutura est√° correta.")

        except Exception as e:
            print(f"‚ùå Erro ao ler PDF: {e}")
            raise

    def merge_data(self):
        """
        Combina os dados do Excel e PDF baseado no c√≥digo do produto.

        Returns:
            pd.DataFrame: DataFrame combinado com todas as informa√ß√µes
        """
        print("\nüîÑ Combinando dados...")

        if self.df_pdf.empty:
            print("   ‚ö†Ô∏è  PDF vazio - adicionando colunas vazias")
            # Se o PDF est√° vazio, apenas adiciona colunas vazias
            df_result = self.df_excel.copy()
            df_result['Qtde_PDF'] = None
            df_result['Pre√ßo_L√≠q_PDF'] = None
        else:
            # Faz o merge usando o c√≥digo extra√≠do do Excel e o c√≥digo do PDF
            df_result = self.df_excel.merge(
                self.df_pdf,
                left_on='C√≥digo Extra√≠do',
                right_on='C√≥digo_PDF',
                how='left'
            )

            # Remove a coluna auxiliar C√≥digo_PDF
            if 'C√≥digo_PDF' in df_result.columns:
                df_result = df_result.drop('C√≥digo_PDF', axis=1)

            matches = df_result['Qtde_PDF'].notna().sum()
            print(f"‚úÖ Combina√ß√£o conclu√≠da: {matches} correspond√™ncias encontradas")

            if matches == 0:
                print("   ‚ö†Ô∏è  Nenhuma correspond√™ncia encontrada!")
                print("   Verifique se os c√≥digos do Excel e PDF est√£o no mesmo formato.")

        return df_result

    def calculate_differences(self, df_result):
        """
        Calcula as diferen√ßas entre Excel e PDF.

        Args:
            df_result (pd.DataFrame): DataFrame com os dados combinados

        Returns:
            pd.DataFrame: DataFrame com as colunas de diferen√ßa adicionadas
        """
        print("\nüî¢ Calculando diferen√ßas...")

        # Diferen√ßa de Quantidade: Qtde_PDF - Compra
        df_result['Diferen√ßa de Qtde'] = df_result['Qtde_PDF'] - df_result['Compra']

        # Diferen√ßa de Pre√ßo: Pre√ßo_L√≠q_PDF - Valor de compra
        df_result['Diferen√ßa de Pre√ßo'] = df_result['Pre√ßo_L√≠q_PDF'] - df_result['Valor de compra']

        # Estat√≠sticas das diferen√ßas
        qtde_dif = df_result['Diferen√ßa de Qtde'].notna().sum()
        preco_dif = df_result['Diferen√ßa de Pre√ßo'].notna().sum()

        # Diferen√ßas significativas (n√£o zero)
        qtde_com_dif = (df_result['Diferen√ßa de Qtde'] != 0).sum()
        preco_com_dif = (df_result['Diferen√ßa de Pre√ßo'] != 0).sum()

        print(f"   Diferen√ßas de Quantidade calculadas: {qtde_dif}")
        print(f"   Com diferen√ßa n√£o-zero: {qtde_com_dif}")
        print(f"   Diferen√ßas de Pre√ßo calculadas: {preco_dif}")
        print(f"   Com diferen√ßa n√£o-zero: {preco_com_dif}")

        return df_result

    def save_result(self, df_result, output_path=None):
        """
        Salva o resultado em um novo arquivo Excel com formata√ß√£o condicional.

        Args:
            df_result (pd.DataFrame): DataFrame com os dados combinados
            output_path (str): Caminho do arquivo de sa√≠da (opcional)
        """
        if output_path is None:
            # Gera nome autom√°tico baseado no arquivo Excel original
            base_path = Path(self.excel_path)
            output_path = base_path.parent / f"{base_path.stem}_comparacao.xlsx"

        print(f"\nüíæ Salvando resultado em: {output_path}")

        try:
            # Cria o writer do Excel
            with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
                df_result.to_excel(writer, index=False, sheet_name='Compara√ß√£o')

                # Ajusta largura das colunas
                worksheet = writer.sheets['Compara√ß√£o']

                # Formata√ß√µes
                red_fill = PatternFill(start_color='FFCCCC', end_color='FFCCCC', fill_type='solid')
                green_fill = PatternFill(start_color='CCFFCC', end_color='CCFFCC', fill_type='solid')
                yellow_fill = PatternFill(start_color='FFFFCC', end_color='FFFFCC', fill_type='solid')
                bold_font = Font(bold=True)

                # Aplica negrito no cabe√ßalho
                for cell in worksheet[1]:
                    cell.font = bold_font

                # Encontra as colunas de diferen√ßa
                headers = [cell.value for cell in worksheet[1]]

                try:
                    qtde_dif_col = headers.index('Diferen√ßa de Qtde') + 1
                    preco_dif_col = headers.index('Diferen√ßa de Pre√ßo') + 1

                    # Aplica formata√ß√£o condicional nas colunas de diferen√ßa
                    for row in range(2, len(df_result) + 2):
                        # Diferen√ßa de Quantidade
                        qtde_cell = worksheet.cell(row=row, column=qtde_dif_col)
                        if qtde_cell.value is not None:
                            try:
                                val = float(qtde_cell.value)
                                if val > 0:
                                    qtde_cell.fill = green_fill  # Mais no PDF
                                elif val < 0:
                                    qtde_cell.fill = red_fill  # Menos no PDF
                            except (ValueError, TypeError):
                                pass

                        # Diferen√ßa de Pre√ßo
                        preco_cell = worksheet.cell(row=row, column=preco_dif_col)
                        if preco_cell.value is not None:
                            try:
                                val = float(preco_cell.value)
                                if val > 0:
                                    preco_cell.fill = red_fill  # Pre√ßo maior no PDF
                                elif val < 0:
                                    preco_cell.fill = green_fill  # Pre√ßo menor no PDF
                            except (ValueError, TypeError):
                                pass

                except ValueError:
                    print("   ‚ö†Ô∏è  Colunas de diferen√ßa n√£o encontradas para formata√ß√£o")

                # Ajusta largura das colunas
                for column in worksheet.columns:
                    max_length = 0
                    column_letter = column[0].column_letter

                    for cell in column:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(str(cell.value))
                        except:
                            pass

                    adjusted_width = min(max_length + 2, 50)
                    worksheet.column_dimensions[column_letter].width = adjusted_width

            print(f"‚úÖ Arquivo salvo com sucesso!")
            print(f"\nüìä Resumo:")
            print(f"   Total de produtos: {len(df_result)}")
            print(f"   Com correspond√™ncia no PDF: {df_result['Qtde_PDF'].notna().sum()}")
            print(f"   Sem correspond√™ncia: {df_result['Qtde_PDF'].isna().sum()}")

            # Resumo das diferen√ßas
            qtde_maior = (df_result['Diferen√ßa de Qtde'] > 0).sum()
            qtde_menor = (df_result['Diferen√ßa de Qtde'] < 0).sum()
            preco_maior = (df_result['Diferen√ßa de Pre√ßo'] > 0).sum()
            preco_menor = (df_result['Diferen√ßa de Pre√ßo'] < 0).sum()

            print(f"\nüìà Diferen√ßas:")
            print(f"   Quantidade maior no PDF: {qtde_maior}")
            print(f"   Quantidade menor no PDF: {qtde_menor}")
            print(f"   Pre√ßo maior no PDF: {preco_maior}")
            print(f"   Pre√ßo menor no PDF: {preco_menor}")

        except Exception as e:
            print(f"‚ùå Erro ao salvar arquivo: {e}")
            raise

    def compare(self, output_path=None):
        """
        Executa o processo completo de compara√ß√£o.

        Args:
            output_path (str): Caminho do arquivo de sa√≠da (opcional)
        """
        print("üöÄ Iniciando compara√ß√£o de pre√ßos...\n")

        # Executa todas as etapas
        self.read_excel()
        self.read_pdf()
        df_result = self.merge_data()
        df_result = self.calculate_differences(df_result)
        self.save_result(df_result, output_path)

        print("\n‚ú® Processo conclu√≠do com sucesso!")


def main():
    """
    Fun√ß√£o principal para executar o script com Tkinter.
    """
    root = tk.Tk()
    root.withdraw()  # Esconde a janela principal

    # Seleciona o arquivo Excel
    excel_path = filedialog.askopenfilename(
        title="Selecione o arquivo Excel",
        filetypes=[("Arquivos Excel", "*.xlsx *.xls")]
    )
    if not excel_path:
        messagebox.showinfo("Cancelado", "Opera√ß√£o cancelada.")
        return

    # Seleciona o arquivo PDF
    pdf_path = filedialog.askopenfilename(
        title="Selecione o arquivo PDF",
        filetypes=[("Arquivos PDF", "*.pdf")]
    )
    if not pdf_path:
        messagebox.showinfo("Cancelado", "Opera√ß√£o cancelada.")
        return

    # Seleciona o caminho de sa√≠da
    output_path = filedialog.asksaveasfilename(
        title="Salvar compara√ß√£o como",
        defaultextension=".xlsx",
        filetypes=[("Arquivos Excel", "*.xlsx")]
    )
    if not output_path:
        messagebox.showinfo("Cancelado", "Opera√ß√£o cancelada.")
        return

    try:
        comparator = PriceComparator(excel_path, pdf_path)
        comparator.compare(output_path)
        messagebox.showinfo("Sucesso", f"Compara√ß√£o conclu√≠da e salva em:\n{output_path}")

    except FileNotFoundError as e:
        messagebox.showerror("Erro", f"Arquivo n√£o encontrado: {e}")
    except Exception as e:
        messagebox.showerror("Erro", f"Erro durante a execu√ß√£o: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()