import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
import pandas as pd
import re
import os
import itertools
import threading
from pathlib import Path


# ==============================================================================
# 1. LÓGICA DE NORMALIZAÇÃO E MATCHING (MANTIDA)
# ==============================================================================

def normalizar_codigo_pdf(codigo: str) -> list:
    if not codigo: return []
    codigo = str(codigo).upper().strip()
    variacoes = set([codigo, codigo.replace('.', ''), codigo.replace('.', '-'), codigo.replace('.', ' ')])

    mapa_fracoes = {'012': '1/2', '034': '3/4', '001': '1', '014': '1/4', '112': '1 1/2', '114': '1 1/4'}
    partes = codigo.split('.')

    if len(partes) >= 2:
        tokens = []
        for p in partes:
            if p in mapa_fracoes:
                tokens.append([p, mapa_fracoes[p]])
            elif re.match(r'^[A-Z]\d{2,3}$', p):
                tokens.append([p, f"{p[0]}-{p[1:]}", f"{p[0]} {p[1:]}"])
            else:
                tokens.append([p])

        for combo in itertools.product(*tokens):
            variacoes.update([" ".join(combo), "-".join(combo), "".join(combo), " ".join(reversed(combo))])
            if len(combo) == 3:
                variacoes.update([" ".join(p) for p in itertools.permutations(combo)])
                variacoes.add(f"{combo[0]}{combo[1]} {combo[2]}")
                variacoes.add(f"{combo[0]}{combo[1]} {combo[2].replace('/', '')}")

    return [v.strip() for v in variacoes if len(v.strip()) > 2]


def buscar_codigo_na_descricao(descricao: str, variacoes_codigo: list) -> bool:
    if not descricao or not variacoes_codigo: return False
    desc_upper = str(descricao).upper()

    # Match "Super Limpo" (ignora pontuação)
    desc_super_limpa = re.sub(r'[^A-Z0-9]', '', desc_upper)

    for v in variacoes_codigo:
        v_upper = v.upper()
        if v_upper in desc_upper: return True

        tokens = v_upper.split()
        if len(tokens) > 1:
            desc_limpa_tokens = re.sub(r'[^\w\s/]', ' ', desc_upper)
            if all((t in desc_limpa_tokens or t in desc_upper) for t in tokens if len(t) > 1):
                return True

        v_super_limpa = re.sub(r'[^A-Z0-9]', '', v_upper)
        if len(v_super_limpa) > 4 and v_super_limpa in desc_super_limpa:
            return True

    return False


def limpar_valor(valor) -> float:
    if pd.isna(valor) or valor == '': return 0.0
    v = str(valor).replace('R$', '').replace('BRL', '').strip()
    if re.search(r'\d{1,3}(\.\d{3})*,\d{2}', v):
        v = v.replace('.', '').replace(',', '.')
    elif ',' in v and v.count(',') == 1 and len(v.split(',')[1]) == 2:
        v = v.replace(',', '.')
    try:
        return float(re.sub(r'[^\d.]', '', v))
    except:
        return 0.0


# ==============================================================================
# 2. LEITURA DE ARQUIVOS (CORRIGIDO A SELEÇÃO DE COLUNAS)
# ==============================================================================

def ler_pdf_extraido(caminho_txt: str) -> pd.DataFrame:
    with open(caminho_txt, 'r', encoding='utf-8') as f:
        conteudo = f.read()
    produtos = []

    padroes = [
        r'(?m)^([A-Z0-9][A-Z0-9.\-]{2,}(?:\.[A-Z0-9]+)*)\s+(?:.*?)\s+(\d{2}/\d{2}/\d{4})\s+(?:BRL\s*)?([\d.,]+)\s+([\d.,]+)',
        r'(?m)^([A-Z0-9][A-Z0-9.\-]{2,}(?:\.[A-Z0-9]+)*)\t.*?\t(\d{2}/\d{2}/\d{4})\t(?:BRL\s*)?([\d.,]+)\t([\d.,]+)'
    ]

    for padrao in padroes:
        for match in re.findall(padrao, conteudo):
            if len(match) < 4: continue
            cod, data, val_s, qtd_s = match[:4]
            cod = cod.strip()
            if len(cod) < 5 or cod == '2025' or 'BRL' in cod or '/' in cod: continue

            qtd = int(limpar_valor(qtd_s))
            if qtd > 0: produtos.append({'Código PDF': cod, 'Qtd PDF': qtd, 'Valor PDF': limpar_valor(val_s)})

    df = pd.DataFrame(produtos)
    return df.drop_duplicates(subset=['Código PDF']) if not df.empty else df


def ler_excel(caminho_excel: str) -> pd.DataFrame:
    df = None
    if not caminho_excel.lower().endswith('.csv'):
        try:
            df = pd.read_excel(caminho_excel, sheet_name="Produtos")
        except:
            try:
                df = pd.read_excel(caminho_excel)
            except:
                pass

    if df is None:  # Tenta CSV
        for enc in ['utf-8', 'latin1']:
            for sep in [';', ',']:
                try:
                    temp = pd.read_csv(caminho_excel, encoding=enc, sep=sep)
                    if temp.shape[1] > 1: df = temp; break
                except:
                    continue
            if df is not None: break

    if df is None: raise Exception("Falha ao ler Excel/CSV.")
    df.columns = [str(c).strip() for c in df.columns]

    # --- CORREÇÃO AQUI: Lógica inteligente para achar a descrição ---
    col_prod = None
    cols_lower = [c.lower() for c in df.columns]

    # 1. Tenta achar coluna "Descrição" (prioridade máxima)
    for c in df.columns:
        if 'descri' in c.lower(): col_prod = c; break

    # 2. Se não achou, tenta "Produto", mas IGNORA se tiver "Código" ou "Cod" junto
    if not col_prod:
        for c in df.columns:
            cl = c.lower()
            if ('produto' in cl or 'nome' in cl) and not ('código' in cl or 'codigo' in cl or 'cod' in cl):
                col_prod = c;
                break

    # 3. Última tentativa: pega qualquer coisa que tenha "produto" (mesmo com código, caso desesperado)
    if not col_prod:
        for c in df.columns:
            if 'produto' in c.lower(): col_prod = c; break

    # Colunas de Valor e Qtd
    col_qtd = next((c for c in df.columns if any(x in c.lower() for x in ['compra', 'qtd', 'quantidade'])), None)
    col_val = next((c for c in df.columns if any(x in c.lower() for x in ['valor', 'preço', 'vlr', 'preco'])), None)

    if not col_prod: raise Exception(f"Coluna de DESCRIÇÃO não encontrada. Colunas: {list(df.columns)}")

    df_novo = pd.DataFrame()
    df_novo['Produto Excel'] = df[col_prod]
    df_novo['Qtd Excel'] = df[col_qtd] if col_qtd else 0
    df_novo['Valor Excel'] = df[col_val] if col_val else 0.0
    return df_novo


# ==============================================================================
# 3. INTERFACE GRÁFICA (MANTIDA)
# ==============================================================================

class ComparadorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Comparador Deca - Final")
        self.root.geometry("800x600")

        self.path_pdf = tk.StringVar()
        self.path_excel = tk.StringVar()

        frame = ttk.LabelFrame(root, text="Arquivos", padding=15)
        frame.pack(fill="x", padx=10, pady=10)

        ttk.Label(frame, text="TXT PDF:").grid(row=0, column=0, sticky="w")
        ttk.Entry(frame, textvariable=self.path_pdf, width=60).grid(row=0, column=1, padx=5)
        ttk.Button(frame, text="...", command=lambda: self.sel_arq(self.path_pdf, "txt")).grid(row=0, column=2)

        ttk.Label(frame, text="Excel/CSV:").grid(row=1, column=0, sticky="w", pady=10)
        ttk.Entry(frame, textvariable=self.path_excel, width=60).grid(row=1, column=1, padx=5)
        ttk.Button(frame, text="...", command=lambda: self.sel_arq(self.path_excel, "xls")).grid(row=1, column=2)

        self.btn = ttk.Button(root, text="PROCESSAR", command=self.iniciar)
        self.btn.pack(pady=10, ipady=5)

        self.log_area = scrolledtext.ScrolledText(root, height=20, font=('Consolas', 9))
        self.log_area.pack(fill="both", expand=True, padx=10, pady=5)
        self.log_area.tag_config('green', foreground='green')
        self.log_area.tag_config('red', foreground='red')
        self.log_area.tag_config('blue', foreground='blue')

    def log(self, msg, tag=None):
        self.log_area.insert(tk.END, msg + "\n", tag)
        self.log_area.see(tk.END)

    def sel_arq(self, var, tipo):
        tipos = [("Texto", "*.txt")] if tipo == "txt" else [("Excel", "*.xlsx *.xls *.csv")]
        f = filedialog.askopenfilename(filetypes=tipos)
        if f: var.set(f)

    def iniciar(self):
        if not self.path_pdf.get() or not self.path_excel.get(): return
        self.btn.config(state='disabled')
        self.log_area.delete('1.0', tk.END)
        self.log("Iniciando...")
        threading.Thread(target=self.processar, daemon=True).start()

    def processar(self):
        try:
            self.log(f"Lendo PDF...")
            df_pdf = ler_pdf_extraido(self.path_pdf.get())
            self.log(f"→ {len(df_pdf)} códigos no PDF.", 'green')

            self.log(f"Lendo Excel...")
            df_excel = ler_excel(self.path_excel.get())
            self.log(f"→ {len(df_excel)} linhas no Excel.", 'green')
            # MOSTRA A COLUNA CERTA AGORA NO LOG
            self.log(f"→ Coluna alvo: {df_excel.iloc[0]['Produto Excel']}", 'blue')

            self.log("\nIniciando cruzamento...", 'blue')
            resultados, matches = [], 0

            for i, row in df_pdf.iterrows():
                cod, qtd, val = str(row['Código PDF']), row['Qtd PDF'], row['Valor PDF']
                variacoes = normalizar_codigo_pdf(cod)
                match_data, melhor_diff = None, float('inf')

                for _, row_ex in df_excel.iterrows():
                    desc = str(row_ex['Produto Excel'])
                    if buscar_codigo_na_descricao(desc, variacoes):
                        diff = abs(val - limpar_valor(row_ex['Valor Excel']))
                        if diff < melhor_diff:
                            melhor_diff = diff
                            match_data = row_ex

                if match_data is not None:
                    matches += 1
                    status = "✓ OK" if (qtd - int(
                        match_data['Qtd Excel'])) == 0 and melhor_diff < 0.1 else "⚠ DIVERGENTE"
                    resultados.append({
                        'Código PDF': cod, 'Qtd PDF': qtd, 'Valor PDF': val,
                        'Produto Excel': match_data['Produto Excel'], 'Qtd Excel': match_data['Qtd Excel'],
                        'Valor Excel': match_data['Valor Excel'], 'Status': status
                    })
                else:
                    resultados.append({
                        'Código PDF': cod, 'Qtd PDF': qtd, 'Valor PDF': val,
                        'Produto Excel': '---', 'Qtd Excel': 0, 'Valor Excel': 0, 'Status': '❌ NÃO ENCONTRADO'
                    })

            saida = Path(self.path_pdf.get()).parent / f"{Path(self.path_pdf.get()).stem}_RELATORIO.xlsx"
            pd.DataFrame(resultados).to_excel(saida, index=False)

            self.log("-" * 40)
            self.log(f"FIM! Match: {matches}/{len(df_pdf)}", 'green' if matches > 0 else 'red')
            self.log(f"Salvo em: {saida}")
            messagebox.showinfo("Concluído", f"Matches: {matches}/{len(df_pdf)}")

        except Exception as e:
            self.log(f"ERRO: {e}", 'red')
            messagebox.showerror("Erro", str(e))
        finally:
            self.btn.config(state='normal')


if __name__ == "__main__":
    root = tk.Tk()
    ComparadorApp(root)
    root.mainloop()